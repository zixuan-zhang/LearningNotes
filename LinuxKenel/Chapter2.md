# 第二章 存储管理
## 2.1 Linux内存管理的基本框架
前面谈过i386 CPU中页式存储管理的基本思路是：通过页面目录和页表分成两个层次实现从线性地址到物理地址的映射。这种映射模式在大多数情况下可以节省页面表所占用的空间。因为大多数进程不会用到整个虚存空间，在虚存中通常留有很大的空洞。采用两层的方式，只要一个目录项所对应的那部分空间是个空洞，就可以把该目录项设置成”空”，从而剩下了对应的页面表（1024个页面描述项）。

Linux内核的设计要考虑到各种不同CPU上的实现，所以不能仅仅针对i386结构来设计它的映射机制，而要以一种假想的、虚拟的CPU和MMU（内存储存单元）为基础，设计一种通用的模型，然后落实到各种具体的CPU上。因此，Linux内核的映射机制设计成三层，在页面目录和页面表中间增设一层“中间目录”。在代码中，页面目录称为PGD，中间目录称为PMD，而页表则称为PT。相应的，在逻辑上也罢线性地址从高位到低位划分成4个位段，各占若干位，分别是PGD、PMD、PT和页内偏移。这样，对于CPU发出的线性地址，虚拟的Linux内存管理单元分成如下的四步完成从线性地址到物理地址的映射：

1. 从线性地址中最高的那一个位段作为下标在PGD中找到相应的表项，该表项指向相应的中间目录PMD
2. 用线性地址中的第二个位段作为下标在此PMD种找到相应的表项，该表项指向相应的页面表
3. 从线性地址中的第三个位段作为下标在页面表中找到相应的表项PTE，该表项中存放的就是指向物理页面的指针。
4. 从线性地址中的最后位段作为物理页面内的相对位移量，将此位移量与目标物理页面的起始地址相加便得到相应的物理地址。

32位地址意味着4G字节的虚存空间，Linux内核将这4G字节的空间分成两部分。将最高的1G字节（0xC0000000~0xFFFFFFFF)用作内核本身，称为“系统空间”，将较低的3G字节（0x0~0xBFFFFFFF）用作各进程的“用户空间”。这样理论上每个进程可以使用的用户空间都是3G字节。虽然各个进程拥有自己的3G字节用户空间，系统空间却由所有的进程共享。每当一个进程通过系统调用进入内核，该进程就在共享的系统空间运行，不再拥有自己独立空间。

虽然系统空间占据了每个虚存空间的1G字节，但是系统空间在物理内存上的地址却是从最低的地址（0）开始。所以对于内核来说，其地址映射是很简单的线性映射（**因此，不使用页式内存管理？？**）。也就是说，对于**系统空间**而言，给定一个虚地址x，其物理地址是从x中减去`PAGE_OFFSET(0xC0000000)`，相应的，给定物理地址x，其虚地址是x+PAGE_OFFSET。

* **所以Linux的内存是三层映射的**

## 2.2 地址映射的全过程
Linux内存采用页式存储管理。虚拟地址空间划分成固定大小的“页面”，由MMU将虚拟地址”映射“成某个物理内存页面中的地址。与段式存储管理相比，页式存储管理有很多好处。
1. 页面都是固定大小的，便于管理
2. 当要将一部分物理空间的内容换到磁盘上的时候，在段式存储管理中要将整个段（通常很大）都换出，而在页式存储管理中则是按页进行，效率就高的多。

页式存储管理与段式存储管理所要祈求的硬件支持不同，一种CPU既然支持页式存储管理，就无需再支持段式存储管理。但是对于i386来说，由于历史原因，CPU一缕缕对程序中的地址先进行段式映射，然后再进行页式映射。既然CPU硬件结构是这样，Linux内核也只好服从Intel的选择。不过这种双重映射其实是毫无必要的，也是映射的过程变得不容易理解。所以Linux内核所采取的办法是使段式映射的过程实际上不起什么作用。

接下来可以看下到底内存映射的过程是什么样的。书中给了一个情景，给出一段代码，代码里函数的地址（虚拟地址）是0x08048368。现在要看下这个虚拟地址是怎样映射到物理地址上了。

### 段式映射阶段
1. 首先是段式映射阶段，由于地址0x08048368是一个程序的入口，更重要的是在执行的过程中是由CPU中的”指令寄存器”EIP所指向的，所以在代码段中。因此i386CPU使用代码段寄存器CS的当前值来作为段式映射的“段选择子”，也就是用它作为在段描述符表中的下表。具体用哪个段描述表，是GDT还是LDT，就要看CS中的内容了。然而，在Linux内核中，在建立一个进程时都要将其段寄存器设置好（CS，SS，ES，DS）。从内核代码中可以看到，段选择子选择的段描述符表都是GDT，不论是各个进程还是内核代码都是GDT。**在这里，实际上有个非常重要的一点。Linux内核中基本不适用局部段描述符表LDT。LDT只是在VM86模式中运行wine以及其他在Linux上模拟Windows软件或DOS软件的程序中才使用**。回到内存映射上。普通的程序显然不属于内核，因此在进程的用户空间中运行，内核在调度该进程进入运行时，把CS设置成`__USER_CS`，即0x23。所以，CPU以4为下标，从全局段描述符表GDT中找到对应的段描述项。出事的GDT内容在内核代码中定义，其主要内容在运行时并不改变。
2. 好了，知道了要从GDT中找到段描述项，并且下标已经知道，就可以找到该描述项了。实际上GDT中只有4个使用的段描述项，分别对应着内核代码段、内核数据段、用户代码段、用户数据段。这四个段描述项的总结如下：
  1. 四个段描述项的下列内容都是相同的
    * B0-B15、B16-B31都是0 ——基地址全部为0
    * L0-L15、L16-L19都是1 ——段的上限全部都是0xFFFFFF（最大值）
    * C位都是1 ——段长单位均为4KB
    * D位都是1 ——对四个段的访问都是32位指令
    * P位都是1 ——四个段都在内存中
    * 结论：每个段都是从0地址开始的整个4GB内存空间，虚地址到线性地址的映射保持原值不变。因此，讨论或理解Linux内核的页式映射时，可以直接将线性地址当做虚拟地址，二者完全一致。
  2. 有区别的地方只是在bit40-bit46，对应于描述项中的type以及S标志和DPL段。
    * 内核代码段：DPL=0，表示0级；S位为1，表示代码段或数据段；type为1010，表示代码段，可读，可执行，尚未受到访问。
    * 内核数据段：DPL=0，表示0级；S位为1，表示代码段或数据段；type为0010，表示数据段，可读，可写，尚未收到访问
    * 用户代码段：DPL=3，表示3级；S位为1，表示代码段或数据段；type为1010，表示代码段，可读，可执行，尚未收到访问
    * 用户数据段：DPL=3，表示3级；S位为1，表示代码段或数据段；type位0010，表示数据段，可读，可写，尚未收到访问。
    * 因此，有区别的地方只有两个：DPL，内核为最高级0级，用户为最低的3级；另一个是段类型，或为代码段，或为数据段。这两项都是CPU在映射过程中要加以检查核对的。如果DPL为0级，而段寄存器CS中的DPL位3级，那说明CPU的当前运行级别比要访问的区段要低，或者如果段描述项说是数据段，而程序中通过CS来访问，那也不允许。所以都是权限、安全的检查工作，而对于实际的地址映射并没有帮助。实际上，在页式内存管理的时候也要对这部分进行检查，只不过对于i386CPU来说，必须进行段式内存映射，因此Linux内核做了这些工作来哄弄下i385CPU。
3. 所里Linux内核设计的段式映射机制把地址0x08048368映射到了其自身。
4. ==有个疑问，段式内存映射里的段长最长为1M，能够允许那么长的段偏移吗== 回答：确实段长度是这些，但是段的单位是4KB，所以加起来一共是32位，就是4GB了。

### 页式映射阶段
每个进程都有其自身的页面目录PGD，指向这个目录的指针保持在每个进程的mm_struct数据结构中。每当调度一个进程进入运行的时候，内核都要为即将运行的进程设置好控制寄存器CR3，而MMU的硬件则总是从CR3中取得指向当前页面目录的指针。不过，CPU在执行程序时使用的是虚拟地址，而MMU硬件在进行映射的时候使用的则是物理地址。而将进程的页面目录的指针写进CR3寄存器使用的是`static inline void switch_mm()`函数，将进程的`pgd`写进CR3，具体的代码是：
```
static inline void switch_mm(struct mm_struct* prev, struct mm_struct* next, struct task_struct* task, unsigned cpu) {
  asmvolatile("movl "%0, %c43": : "r"(__pa(next->pgd))); // 将下一个进程next的pgd先通过__pa函数转成物理地址，然后写进CR3寄存器。
}
```
那么，这样会有问题吗？在这一行前后CR3的值不一样，也就是使用了不同的页面目录，不会使程序的执行不能连续了吗？答案是，在内核中，不管什么进程，一旦进入内核就进了系统空间，都有相同的页面映射，所以不会有问题。

所以，当程序要转移到地址0x08048368去的时候，进程正在进行，CR3早已设置好，指向当前进程的页面目录了。现在就要根据线性地址去转成物理地址。具体过程如下：
1. i386CPU根据线性地址的高10位组成的值作为下标去页面目录中找到该目录项。
2. 该目录项的高20位指向一个页面表。CPU在这20位后天上12个0就得到了该页面表的指针。（页面的大小为4k，正好是12位）。并且此目录项的低12位挪作他用，其中最低位为P标志位，为1时表示该页面表再内存中，为0时表示该页面表不在内存中。
3. i386CPU根据线性地址的中间10位，以此值作为下标，根据页面表指针找到该页面项。于目录项相似，当页面项的P标志位为1时表示映射的页面在内存中。32位的页面表项的高20位指向一个物理内存页面，后面填12个0就得到了物理内存页面的起始地址。这次指向的就是具体的页面了。在其地址上加上线性地址中的低12位就得到了最终的物理内存地址。

具体在查找的时候还涉及到了高速缓存。这个先不表。

### 2.2.1 改变LDT的内核函数
除了常规的页式映射之外，为了能在Linux内核上仿真运行采用段式存储管理的Windows软件，内核提供了一个特殊的，于段式存储管理相关的系统调用。
```
modify_ldt(int func, void* ptr, unsigned bytecount) {}
```
这个系统调用可以用来改变当前进程的局部段描述符。系统调用`modify_ldt()`就是因开发WINE而需要设置的。func的值为0时，该调用返回本进程局部段描述符表的实际大小，而表的内容就在用户通过ptr提供的缓存区中。也就是说会把LDT的内容读取到ptr指向的地址中去。而当func的参数为1时，就会将ptr指向的地址上的内容写到进程的LDT上去。**原理、怎样使用我现在还不清楚**

## 2.3 几个重要的数据结构和函数
Linux内核只要能为硬件准备好页面目录PGD、页面表PT以及全局段描述表GDT和局部段描述表LDT，并正确的设置有关的寄存器，就完成了内存管理机制中的 **地址映射** 部分的准备工作。在与内存管理有关的内核代码中，有几个数据结构是很重要的，

这部分的内容有点多，而且比较难懂，我看了一遍并没有看太懂，所以也没什么好记录的，先暂时放下，往后翻翻再说。
