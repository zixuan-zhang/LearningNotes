# 第一章 预备知识

## 1.1 Linux内核简介

* Unix->Minix->Linux
* 微内核：内核的核心工作是为进行提供服务，例如进程间通信等，而各个进程都是游离在内核之外，进程间的关系采用server/client的结构。因此内核的工作比较单一，被称为微内核，例如Minix。微内核的好处是内核的工作比较简单，缺点是由于各个进程都是在内核之外，因此效率较低。
* 宏内核：将各个进行都运行在内核之中，以及内核之间的通信等。好处是效率比较高，比较适合大型的系统。例如linux。linux即支持将进程编译进内核，也支持一些设备驱动以模块的方式动态链接到内核中。
* 安装好后的Linux系统，内核的源代码位于/usr/src/linux目录价。

## 1.2 Intel X86 CPU系列的寻址方式
### X86系列的演变历史
所谓X86系列，是指Intel从16位微处理器8086开始的整个CPU芯片系列，系列中的没种型号都保持与以前的各种型号的兼容。在X86系列中，8086和8088是16位处理器，而从80386开始为32位处理器。这就是从“实地址模式”到“保护模式”的演变。

### 实地址模式
不用考虑”实地址”的意义，“实地址模式”是相对于”保护模式而言的，是指该CPU并没有对内存进行管理，每个进程都可以随意的访问内存中的所有地址，并没有加以保护，所以称不上“保护模式”，因而被称为”实地址模式”。那么为何8088之前的CPU并没有内存保护机制呢？

以8086为例。8086采用了1M字节的内存地址空间，为了对这1M内存地址空间进行寻址，需要地址总线的宽度为20位。然而，虽然地址总线的宽度为20位，但是CPU中的算数逻辑单元只有16位。为了填补这个空隙，8086 CPU中设置了四个“段寄存器”：CS、DS、SS、ES。每个段寄存器都是16位的。当CPU要访问内存地址时，由于ALU的宽度只有16位，当送入地址总线之前，需要计算出20位的内存地址。这20位的内存地址的计算方案为：

> 首先选择四个段寄存器中的一个寄存器，这个寄存器的前4位地址作为20位内存地址的高4位，接下来的12位地址由该寄存器的低12位与ALU的高12位进行相加，ALU的低4位作为内存地址剩下的低4位。

通过这种方式，就组成了内存地址的20位地址空间了。这种方法与操作系统理论中的“段式内存管理”相似，但是没有地址空间的保护机制。对于每一个由段寄存器的高4位确定的”基地址”，一个进程总能够访问由此开始的64K字节的连续地址空间，而进程可以随意改变寄存器的值，因此一个进程可以随意访问内存空间的所有单元，而不能加以保护。因此被称为“实地址模式”。

### 保护模式和段式内存管理
（这一部分内容较复杂，尚未完全消化，待补充）
Intel的设计人员在保护模式下改变段寄存器的功能，使其从一个单纯的基地址变成了指向一个数据结构的指针。其过程如下（总体思想）：

1. 根据指令的性质来确定应该使用哪一个段寄存器，例如转移指令中的地址在代码段，而取收指令中的地址在数据段。
2. 根据段寄存器的内容，找到相应的“段地址描述符结构”
3. 从地址段描述符结构中得到基地址。
4. 将指令中的地址作为位移，于段描述符中规定的段长度相比，看看是否越界
5. 根据指令的性质和断面描述符中的访问权限确定是否越权。即权限检查。
6.  将指令中发出的地址作为位移，于段描述符得到的基地址相加得到实际的“物理地址”

实际的80386段式内存管理机制是这样的。首先80386 CPU中增加了两个寄存器：全局性段描述表寄存器GDTR(Global Descriptor Table Register)，另一个是局部段描述符表寄存器LDTR(Local Descriptor Table Register)。而原先的段寄存器并不存储基地址，而是存储段描述符表项的index。具体操作是这样的：
1. 首先选择从段寄存器中选择合适的那个段寄存器。在段寄存器中，根据TI位来选择使用GDTR还是LDTR。
2. 选择了段描述符表寄存器后，段描述符表寄存器里保存了段描述符表的基地址，然后再根据段描述符存储了段根据段寄存器的高13位(15-3)，确定了该段描述符项在内存中的地址。
3. 找到了该段描述符项之后，这个段描述符项里保存了该段的基地址。
4. 根据该段的基地址以及ALU中提供的段偏移，两个加起来确定最终的物理地址（如果有页式内存管理的话，就叫做线性地址）。由此，段式内存管理寻址结束。
5. 当然，在这个过程中还要对权限、是否越界等进行检查。所以这个过程中有可能会出现Segment Fault的异常。

对于Windows系统而言，由于存在页式内存管理，因此所有的段描述符表项里的基地址都是0x0，段长度设为最大，这样就形成了一个从0开始覆盖整个32位地址空间的整段。，这样就构成了（平面地址）Flat Mode。

利用80386对段式内存管理的硬件支持，可以实现段式虚存管理。当一个段寄存器的内容改变时，CPU要根据新的段寄存器的内容以及GDTR或LDTR的内容找到相应的段描述符项并将其装入CPU中。在此过程中，CPU会检查该描述项中的p标志位，如果p标志位为0，就表示该描述项所指向那段内容不在内存中（也就是说在磁盘中的某个地方），此时CPU会产生一次异常（类似于终端），而相应的服务程序便可以从磁盘交换区将这一段内容读入到内存中的某个地方，并设置描述项中的基地址，再将p标志位设置成1.相应的，内存中暂时不需要的存储段可以写入磁盘 ，并将其描述项中的p标志位设置为0.

保护模式之所以成为保护模式，是可以对内存进行一定的保护操作。具体的，需要一些特权指令来装入和存储GDTR和LDTR，这些特权指令只能在系统状态中使用。每一个指令都有特权级。

## 1.3 i386的页式内存管理机制
内存管理有两种，一种是段式管理，另一种是页式管理，而页式管理更为先进。Intel从80286开始实现了“保护模式”，也就是段式内存管理，但是发现光有段式管理是不够的，因此在80386中就实现了对页式内存管理的支持。80386除了完成并完善从80286开始的段式内存管理的同时还实现了页式内存管理。（为什么段式内存管理机制是低效的，这个问题在书中也没有说的太清楚，我也没看太明白，所以不总结了，有空再读一遍。）

段式内存管理机制的灵活性和效率都比较差。一方面，段长度是可以变化的，这就给盘区交换操作带来了不便（不懂）；另一方面，为了增加灵活性而降一个进程的空间划分成很多小段，就势必在程序中频繁的改变段寄存器的内容。同时，如果将段分小，虽然一个段描述符表中可以容纳9192个描述项，也未必保证足够使用。所以最好的办法还是采用页式内存管理。

由于i386上已经实现了段式内存管理机制，所以i386上的页式内存管理机制是在段式管理机制的基础上建立的。因此段式存管映射后的地址不再是”物理地址了”，而被称为“线性地址”。所以段式存管先将逻辑地址映射成线性地址，然后再由页式存管将线性地址映射成物理地址。因此，对32位的线性地址有了新的解释
```
typedef struct {
  unsigned int dir : 10; // 用作页面表目录的下表，该目录项指向一个页面表
  unsigned int page : 10; // 用作页面表的下表，该表项指向一个物理页面
  unsigned int offset : 12; // 在4k字节物理页面内的偏移量
}
```
类似于GDTR和LDTR，又增加了一个新的寄存器CR3作为指向当前页面目录的指针。由上面可以看出，在页面目录中共有1024个目录项，每个目录项指向一个页面表，而在每个页面表中又有1024个页面描述项。这样从线性地址到物理地址的映射过程为：
1. 从CR3中取得页面目录的基地址
2. 以线性地址中的dir(31-22)位段为下标，在所得页面表中取得相应的页面描述项
3. 以线性地址中的page(21-12)位段为下标，在所得到的页面表中取得相应的页面描述项
4. 将页面描述项中给出的页面基地址于线性地址中的offset位段相加得到物理地址。

页目录项中含有一个指向一个页面表的指针，而页面表项中则含有一个纸箱一个页面起始地址的指针。由于页面表和页面的起始地址总是在4k的边界上，因此这些指针得的低12位永远是0.这样目录项和页表中都只要20位就够了，余下的12位则可以用于控制或其他目的。其中一个为被称为p位，当其为0时，表示相应的页面或页面表不在内存中，根据其他有关寄存器的设置，CPU可以产生一个“Page Fault”异常，也被称为缺页终端。内存的有关异常服务程序就可以从磁盘上的页面交换区将相应的页面读入内存，设置相应的表项中的基地址，并将该p位设置为0.

这就是也是内存管理。

## 1.4 Linux内核中C语言和汇编语言
（没有仔细看，看不懂哇。）
