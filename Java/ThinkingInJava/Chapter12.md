# 第12章 传递和返回对象

到目前为止，读者应该对对象的“传递”有一个较为深刻的认识，记住实际传递的只是一个句柄。在许多程序语言中，我们可用语言的“普通”方式到处传递对象，而且大多数的时候都不会遇到问题。Java中，我们有必要准确认识对象传递和赋值时所发生的一切。

## 12.1 传递句柄

将句柄传递进一个方法时，指向的仍是相同的对象。但是在函数体内，这个句柄和之前的句柄不是一个句柄。

### 12.1.1 别名问题

“别名”意味着多个句柄都试图指向同一个对象，就像前面的例子中展示的那样。若有人向哪个对象里写点什么东西，会直接改变这个对象，因此就会影响其他句柄。

## 12.2 制作本地副本

Java中所有自变量活着参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的一个句柄。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：

* 参数传递过程中会自动产生别名问题。即值传递。
* 不存在本地对象，只有本地句柄
* 句柄有自己的作用域，而对象没有
* 对象的“存在时间”在Java里不是一个问题。
* 没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）

若只是从对象中读取信息，而不去修改它，传递句柄便是自变量传递中最有效的一种形式。**如果我们仍需要将对象当作本地对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响，许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本。但Java没有这种能力，但允许我们达到同样的效果**

### 12.2.1 按值传递

对于按值传递的含义，目前存在两种明显区别的见解：

1. Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确的到几本数据类型的一个副本。但若将一个句柄传递进入一个方法，的到的是句柄的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略自己处理的是一个句柄。也就是说，它允许我们将句柄假想成“对象”，因为在发出方法调用时，系统会自动照管两者的差异
2. Java主要按值传递（无自变量），但对象却是按引用传递的。的到这个结论的前提是句柄只是对象的一个别名，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时并没有获得对象的一个本地副本，所以对象显然不是按值传递的。

### 12.2.2 克隆对象

若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需要简单的使用`clone()`方法即可。C这个方法在基础类Object中定义成`protected`模式。但是希望克隆的任何衍生类中，必须将其覆盖未`public`模式。

### 12.2.3 使类具有克隆能力

尽管克隆方法是在所有的类中最基本的Object中定义的，但克隆仍然不会在每个类中自动进行，因为在Object类中，clone方法是protected的。

1. 使用Protected时的技巧

   因为Object类中clone方法时protected，因此对那些简单实用一下这个类的程序来说，它们不会默认拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用`clone()`。但是，加入我们是在一个从Object衍生出来的类中，就有权调用`Object.clone()`，因为它时`protected`。基础类`clone()`提供了一个有用的功能——它进行的是对衍生类对象的真正“按位”复制，所以相当于标准的克隆。**然而，我们随后需要将自己的克隆操作设置为public，否则无法访问之。**总之，克隆时需要注意的两个关键问题是：几乎肯定要调用`super.clone()`，以及注意将克隆设为`public`。

2. 实现`Cloneable`接口

   为使一个对象的克隆能力工程圆满，还需要做另外一件事：实现`Cloneable`接口。这个接口有点奇怪，因为它是空的。`interface Cloneable{}`之所以要实现这个接口，显然不是因为我们准备上溯造型成一个`Cloneable`的对象以及调用它的某个方法。Cloneable interface的实现扮演了一个标记的角色，封装到类的类型中。有两个方面的原因促成了Cloneable interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。这种情况下，可使用instanceof关键字调查句柄却是痛一个能克隆的对象连接。`if (handler instanceof Cloneable)`。第二个原因考虑到我们可能不愿所有的对象类型都能克隆。所以`Object.clone()`会验证一个类是否真的是实现了`Cloneable`接口。若答案是否定的，则“掷出”一个`CloneNotSupportedException`违例。所以在一般情况下，我们必须讲`implement Cloneable`作为对克隆能力提供支持的一部分。

### 12.2.4 成功的克隆

`clone()`必须能够访问，所以必须将其设为public。其次，作为`clone()`的初期行动，它应调用`clone()`的基础类版本。`Object.clone()`会检查原来的对象有多大，再为新对象腾出足够多的内存，将所有的二进制位从原来的对象复制到新的对象。

Java对“是否等价”，即等号=的测试并不对所比较的内部进行检查，而是核实它们的值是否相同。如果是句柄，则检查对比句柄的内容，如果句柄的地址相同，就认为句柄指向相同的对象，所以认为它们是等价的。

### 12.2.5 `Object.clone()`的效果

`Object.clone()`方法负责建立正确的存储容量，并通过“按位复制”将二进制位从原始对象复制到心对象。这个时候需要用RTTI判断欲克隆对象的实际大小。因此不管需要做什么，克隆过程的第一步通常是调用`super.clone()`进行一次准确的复制，这样可以为后续的克隆建立良好的基础。

通常可在一个能克隆的类里调用`super.clone()`，以确保所有的基础类行动能够进行。随着位对象内每个句柄都明确调用一个`clone()`，否则那些句柄会别名变成原始对象的句柄。构造器的调用也大致相同——首先构造基类，然后是子类。

### 12.2.6 克隆合成对象

试图深层复制合成对象时会遇到一个问题。必须假定成员对象中的`clone()`方法也能依次对自己的句柄进行深层复制，以此类推。

### 12.2.8 通过序列化进行深层复制

