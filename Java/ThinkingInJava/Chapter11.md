# Chapter 11 运行期类型鉴定

运行期类型鉴定（Runtime Type Identification)的概念：手上只有一个基础类型的一个句柄时，利用它判断一个对象的正确类型。

本章将讨论如何利用Java在运行期查找对象和类信息。主要采用两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可以在运行期独立查找类信息。

## 11.1 对RTTI的需要

### 11.1.1 Class对象

为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期间是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类相关的信息。事实上，我们要用Classs对象创建属于某个类的全部“常规”或“普通”对象。

作为程序一部分的每个类，都有一个Class对象。换言之，每次写一个类时，同时会创建一个Class对象（更恰当的说，是保存在一个完全同名.class文件中）。在运行期，一旦我们想生成那个类的一个对象，用于执行程序的JVM首先会检查那个类型的Class对象是否已经载入。若尚未载入，JVM就会查找同名的.class文件，并将其载入。所以Java程序启动时并不是完全载入的。一旦那个类型的Class对象进入内存，就用它来创建那一类型的所有对象。

### 11.1.2 造型前的检查

迄今为止，我们已知的RTTI形式包括：

1. 经典造型，如“(Shape)"，它用RTTI来确保造型的正确性，并在遇到一个失败的造型后产生一个ClassCastException违例
2. 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。

在C++中，经典的"(Shape)"造型并不执行RTTI，它只是简单的告诉编译器将对象当作新类型处理。而Java要执行类型检查，这通常叫做"类型安全"的上溯造型。**编译器不允许自动下溯造型，除非明确制定一次这样的造型。**

RTTI在Java中存在三种形式，关键字instance告诉我们对象是不是一个特定类型的实例。它会返回一个布尔值。就像这样：

```
if (x instanceof Dog){
  ((Dog)x).bark();
}
```

将x造型至一个Dog前，上面的if语句会检查对象x是否属于Dog类。进行造型之前，如果没有其他信息可以告诉自己对象类型，那么`instanceof`的使用时非常重要的，否则会得到一个`ClassObjectException`违例。

## 11.2 RTTI语法

Java用Class对象实现自己的RTTI功能——即便我们要做的只是像造型那样的一些工作。Class类也提供了其他大量的方式，以方便我们使用RTTI。

首先必须获得指向适当Class对象的一个句柄。就像前例演示的那样，一个办法时用一个字串以及Class.forName()方法。这是非常方案的，因为不需要那种类型的一个对象来获取Class句柄。如果已经有了一个对象，则直接使用`object.getClass()`即可返回一个特定的Class句柄，用来表示对象的实际类型。

下面是一些有用的Class对象用法：

1. `Class.getInterfaces()`方法会返回Class对象的一个数组，用于表示旱灾Class对象内的借口。
2. `Class.getSuperclass()`查询该对象的直接基础类是什么。这种会返回一个Class句柄，可以用它作进一步的查询。这意味着在运行期的时候，完全由机会调查到对象的完整层次结构。
3. `Class.newInstance()`创建对象。用`newInstance()`函数创建的类必须有一个默认构造期。**没有办法用`newInstance()`创建拥有非默认构造期的对象。然后Java1.1的"反射"API却允许我们动态的使用类里的任何构造器。

## 11.3 反射：运行期类信息

如果不知道一个对象的准确类型，RTTI会帮助我们调查。但是却有一个限制：类型必须是在编译期间已知的，否则就不能用RTTI调查它，今儿无法展开下一步的工作。换言之，编译器必须明确知道RTTI要处理的所有类。

在Java1.1种，Class类得到了扩展，可以支持“反射”的概念。针对Field，Method以及Constructor类（每个都实现了Member interface——成员借口），他们都新增了一个库：`java.lang.reflect`，这些类型的对象都是JVM在运行期创建的，用于代表未知类里对应的成员。这样便可用构建器来创建新对象，用get()和set()方法读取和修改与Field对象关联的字段，以及用`invoke()`方法调用与Method兑现关联的方法。此外，我们可调用方法`getFileds(), get Methods(), getConstructors()`	分别返回用于表示字段，方法以及构造器的对象数组。因此，匿名对象的类信息可以在运行期间被完整的揭露出来，而在编译期不需要知道任何东西。“发射”并没有什么神奇的地方，通过“反射”同一个未知类型的对象打交道时，JVM只是简单的检查那个对象，并调查它属于哪个特定的类。但是在这之后，在我们做任何其他事情之前，Class对象必须被载入。因此，用于那种特定类型的.class文件必须能够由JVM调用（要么在本地机器内，要么可以通过网络）。所以RTTI和“反射”之间的唯一区别就是对RTTI来说，编译器会在编译期打开和检查.class文件。换句话说，我们可以用“普通”方式调用一个对象的所有方法，但对“反射”来说，.class文件在编译期间时不可用的，而是由运行期环境打开和检查。

### 11.3.1 一个类方法提取器

## 11.4 总结

利用RTTI可以根据一个匿名的基础类句柄调查处类型信息。但是只有在极特别的情况下才使用RTTI。但是为了多形性，要求我们拥有对基础类定义的控制权，因为有些时候在程序范围内，可能发现基础类并未包括我们想要的方法。若基础类来自一个库，或者由别的什么东西控制着，RTTI便是一个很好的解决方案：可继承一个新类型，然后添加自己的额外方法。在代码的其他地方，可以侦测自己的特定类型，并调用哪个特殊的方法。这样并不会破坏多形性以及程序的扩展能力，因为新类型的添加不要求查找程序中的switch语句。但是在需要新特性的主题种添加新代码时，必须使用RTTI侦测自己特定的类型。