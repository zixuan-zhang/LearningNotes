# Chapter5 初始化与清理
## 5.5 清理：终结处理和垃圾回收
Java垃圾回收器负责回收无用对象占据的内存资源，但是垃圾回收只释放哪些经由new分配的内存。Java允许在类中定义一个`finalize()`的方法。它的工作原理：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用`finalize()`方法，并且在下一次垃圾回收动作发生时才会真正回收占用的内存。

刚开始，有的程序员可能误把`finalize()`当做C++中的析构函数，所以这里必须明确区分一下：C++中，对象一定会被销毁（执行析构函数），而Java里的对象却并非总是被垃圾回收。或者换句话说：
1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”
3. 垃圾回收只与内存有关。也就是说垃圾回收器的唯一原因是为了回收程序不再使用的内存。

之所以要有`finalize()`，是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要是发生在使用”本地方法“的情况下。本地方法是一种在Java中调用非Java代码的方式。目前只支持C和C++。在非Java代码中，也许会调用C语言的`malloc()`函数来分配空间，除了使用`free()`方法，没有办法释放。所以要在`finalize()`方法中调用它。

### 5.5.4 垃圾回收器如何工作
Java中的垃圾回收器对于提高对象的创建速度有明显的效果。Java从堆分配空间的速度，可以和其他语言堆栈上分配空间的速度向媲美。

垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就可以很容易移动到更靠近传送带的开始出，尽量避免了页面错误。通过垃圾回收器对对象的重新排列，实现了一种高速的、有无限空间可供分配的堆模型

引用计数是一种简单但是速度很慢的垃圾回收技术。每个对象都有一个引用计数器，当有引用连接至对象时，引用计数加1.当引用离开作用域时被置为null，引用计数减一。当引用计数变为0时释放对象。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但是引用计数却不为0”。对于垃圾回收器而言，定位这样的交互引用的对象工作量极大。引用计数常用来说明垃圾回收的工作方式，但是从未被应用到任何一种Java虚拟机实现中。

在一些更快的模式中，垃圾回收的思想史：对任何“活的对象”，一定能最终追溯到其存货在堆栈或者静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的对象，就能找到所有“活的对象”。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用，如此反复，知道”根源于堆栈和静态存储区的引用“所形成的网络被全部访问为止。

在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。一种机制叫做“停止-复制”。这种方式，要先暂停程序的运行，然后将所有活的对象从当前堆复制到另一个堆，没有被复制的，全是垃圾。当他们被复制到新堆时，是一个挨着一个的，因此新堆保持紧密排列，就可以按照前述方法简单、直接的分配新空间了。当把对象从一处复制到另一处时，所有指向它的引用必须得到修正。位于堆或静态存储区的应用可以直接被修正，但是可能还有其他指向这个对象的引用，他们在遍历的过程中才能被找到。对于这种”复制式回收器”，效率会降低。首先，得有两个堆，所以维护比实际需要多一倍的空间。某些虚拟机对此问题的处理方式是，按需从堆中分配几块比较大的内存，复制动作发生在大内存之间。另一问题在于复制。程序在稳定之后只可能产生少量垃圾，复制式仍然会将所有内存自一处复制到另一处。所以为了避免这种方式，Java虚拟机会进行检查，如果没有新的垃圾，就会转到“标记-清扫”模式。这就是“自适应”。

"标记-清扫"所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存货的对象。每当它找到一个存货的对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作，所以剩下的堆空间是不连续的，垃圾回收器如果希望得到连续空间的话，就得重新整理剩下的对象。

“停止-复制”的意思是这种垃圾回收的动作不是在后台进行的，程序将被暂停。

## 5.6
1. 对于局部变量，如果不初始化，编译器就会报错
2. 对于类里的数据成员，如果没有初始化，就有默认的值

## 5.7 构造器初始化
### 5.7.1 初始化顺序
在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，他们仍旧会在任何方法包括构造器被调用之前得到初始化。

### 5.7.2 静态数据初始化
无论创建多少对象，静态数据都只占用一份存储区域。**在Java中，static关键字不能应用于局部变量，因此只能作用于域**。

**注意**：静态成员是在需要的时候才初始化，否则不初始化。总结一下对象的创建过程：
1. 即使没有显示的使用static关键字，构造器实际上也是静态方法。因此首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件
2. 然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。京瓷，静态初始化只在Class对象首次加载的时候进行一次
3. 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间
4. 这块存储空间会被清零，这就自动的将Dog对象中的所有基本类型数据都设置成默认值，而引用被设置成null
5. 执行所有出现于子段定义出的初始化动作，按照定义的顺序
6. 执行构造器。

## 5.8 数组初始化
### 5.8.1 可变参数列表
语法
```
void printArray(Object... args) {
  for (Object obj : args) {
    System.out.println(obj + " ");
  }
}
```
## 5.9 枚举类型
`enum`关键字可以被认为是一个特殊的类
