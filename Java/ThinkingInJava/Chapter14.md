# Chapter 14 类型信息

运行期类型鉴定（Runtime Type Identification)的概念：手上只有一个基础类型的一个句柄时，利用它判断一个对象的正确类型。

本章将讨论如何利用Java在运行期查找对象和类信息。主要采用两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可以在运行期独立查找类信息。

## 14.1 对RTTI的需要

## 14.2 Class对象

为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期间是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类相关的信息。事实上，我们要用Classs对象创建属于某个类的全部“常规”或“普通”对象。

作为程序一部分的每个类，都有一个Class对象。换言之，每次写一个类时，同时会创建一个Class对象（更恰当的说，是保存在一个完全同名.class文件中）。在运行期，一旦我们想生成那个类的一个对象，用于执行程序的JVM首先会检查那个类型的Class对象是否已经载入。若尚未载入，JVM就会查找同名的.class文件，并将其载入。所以Java程序启动时并不是完全载入的。一旦那个类型的Class对象进入内存，就用它来创建那一类型的所有对象。

### 14.2.1 类字面常量

Java还提供了另一种方法来生成对Class对象的引用：`FancyToy.class`，这样做不仅简单，而且更安全，因为他在编译时就受到检查，因此不需要至于try语句块中。类字面常量不进可以应用于普通的类，也可以应用于接口、数组以及几本数据类型。另外，对于几本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的几本数据类型的Class对象。

当使用".class"来创建Class对象时，不会自动地初始化该Class对象，为了使用类而做的工作包含了三个步骤：

1. 加载。这是由类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但是非必需的），并从这些字节码中创建一个Class对象。
2. 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的对其他类的所有引用。
3. 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。


如果一个static final值是“编译期常量“， 那么这个值不需要对类进行初始化就可以被读取。但是，如果只是将一个域设置成static和final的，还不足以确保这种行为。

如果一个static域不是final的，那么在对他进行访问时，总是要求在它被读取之前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间）。

### 14.2.2 泛化的Class引用

Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的静态成员，因此Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。

为了在使用泛化的Class引用时放松限制，我们使用通配符，它是Java泛型的一部分。通配符就是"?"，表示任何事物。就像下面这样：

```java
Class<?> intClass = int.class;
intClass = double.class
```

在Java SE5中，Class<?>优于平凡的Class，即便它们是等价的，并且平凡的Class如你所见，并不会产生任何警告信息。Class<?>的好处是，表示并非是碰巧或者由于疏忽，而使用了一个非具体的类引用，你就是选择了非具体的版本。还有下面的版本，表明可以是任何继承自Number的类：

```java
Class<? extends Number> bounded = int.class;
bounded = double.class;
bouneed = Number.class;
```

## 14.2.3 新的转型语法

Java SE5还添加了用于Class引用的转型语法，即cast()方法：

```java
class Building {}
class House extends Building {}
public class ClassCasts {
  public static void main(String[] args) {
    Building b = new House();
    Class<House> houseType = House.class;
    House h = houseType.cast(b)
    h = (House)b; // or just do this.
  }
}
```

这个语法不经常遇到，他比普通的转型，如`(House)`转型相比，做了些其他的工作。

## 14.3 类型转化前先做检查

迄今为止，我们已知的RTTI形式包括：

1. 经典造型，如“(Shape)"，它用RTTI来确保造型的正确性，并在遇到一个失败的造型后产生一个ClassCastException违例
2. 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。

在C++中，经典的"(Shape)"造型并不执行RTTI，它只是简单的告诉编译器将对象当作新类型处理。而Java要执行类型检查，这通常叫做"类型安全"的上溯造型。**编译器不允许自动下溯造型，除非明确制定一次这样的造型。**

RTTI在Java中存在三种形式，关键字instance告诉我们对象是不是一个特定类型的实例。它会返回一个布尔值。就像这样：

```
if (x instanceof Dog){
  ((Dog)x).bark();
}
```

将x造型至一个Dog前，上面的if语句会检查对象x是否属于Dog类。进行造型之前，如果没有其他信息可以告诉自己对象类型，那么`instanceof`的使用时非常重要的，否则会得到一个`ClassObjectException`违例。

## 14.6 反射：运行期类信息

如果不知道一个对象的准确类型，RTTI会帮助我们调查。但是却有一个限制：类型必须是在编译期间已知的，否则就不能用RTTI调查它，今儿无法展开下一步的工作。换言之，编译器必须明确知道RTTI要处理的所有类。

在Java1.1种，Class类得到了扩展，可以支持“反射”的概念。针对Field，Method以及Constructor类（每个都实现了Member interface——成员借口），他们都新增了一个库：`java.lang.reflect`，这些类型的对象都是JVM在运行期创建的，用于代表未知类里对应的成员。这样便可用构建器来创建新对象，用get()和set()方法读取和修改与Field对象关联的字段，以及用`invoke()`方法调用与Method兑现关联的方法。此外，我们可调用方法`getFileds(), get Methods(), getConstructors()`	分别返回用于表示字段，方法以及构造器的对象数组。因此，匿名对象的类信息可以在运行期间被完整的揭露出来，而在编译期不需要知道任何东西。“发射”并没有什么神奇的地方，通过“反射”同一个未知类型的对象打交道时，JVM只是简单的检查那个对象，并调查它属于哪个特定的类。但是在这之后，在我们做任何其他事情之前，Class对象必须被载入。因此，用于那种特定类型的.class文件必须能够由JVM调用（要么在本地机器内，要么可以通过网络）。所以RTTI和“反射”之间的唯一区别就是对RTTI来说，编译器会在编译期打开和检查.class文件。换句话说，我们可以用“普通”方式调用一个对象的所有方法，但对“反射”来说，.class文件在编译期间时不可用的，而是由运行期环境打开和检查。

### 14.6.1 一个类方法提取器

## 14.7 动态代理

代理是几本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来替代“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。

**自己去书里看例子**

在任何时候，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易的做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就很有用（设计模式的关键就是封装修改——因此你需要修改事务已证明这种模式的正确性）。比如，你希望跟踪对RealObject的方法的调用，或者希望度量这些调用的开销，使用代理可以很容易的添加或移除它们。

**Java的动态代理比代理的思想更进一步** ，因为它可以动态的创建代理并动态的处理对所代理方法的调用。在动态代理商所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。

**关于动态代理请参考设计模式**

## 14.8 空对象

## 14.9 接口与类型信息

interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。如果你编写接口，那么久可以实现这一目标，但是通过类型信息，这种耦合性就会传播出去——接口并非是对解耦的一种无懈可击的保障。

```java
public interface A {
  void f();
}
class B implements A {
  public void f() {}
  public void g() {}
}
public class InterfaceViolation {
  public static void main(String args) {
    A a = new B();
    a.f();
    // a.g(); Compile error
    if (a instanceof B) {
      B b = (B)a;
      b.g();
    }
  }
}
```

通过使用RTTI，我们发现a是被当作B实现的。通过将其转型为B，我们可以调用不在A中的方法。

来看个使用反射来获取到private函数的方法

```java
Method g = a.getClass().getDeclaredMethod(methodName);
g.setAccessible(true);
g.invoke(a);
```

## 14.10 总结

RTTI允许通过匿名基类的引用来发现类型信息。

还有一些关于发射的讨论

## 11.2 RTTI语法

Java用Class对象实现自己的RTTI功能——即便我们要做的只是像造型那样的一些工作。Class类也提供了其他大量的方式，以方便我们使用RTTI。

首先必须获得指向适当Class对象的一个句柄。就像前例演示的那样，一个办法时用一个字串以及Class.forName()方法。这是非常方案的，因为不需要那种类型的一个对象来获取Class句柄。如果已经有了一个对象，则直接使用`object.getClass()`即可返回一个特定的Class句柄，用来表示对象的实际类型。

下面是一些有用的Class对象用法：

1. `Class.getInterfaces()`方法会返回Class对象的一个数组，用于表示旱灾Class对象内的借口。
2. `Class.getSuperclass()`查询该对象的直接基础类是什么。这种会返回一个Class句柄，可以用它作进一步的查询。这意味着在运行期的时候，完全由机会调查到对象的完整层次结构。
3. `Class.newInstance()`创建对象。用`newInstance()`函数创建的类必须有一个默认构造期。**没有办法用`newInstance()`创建拥有非默认构造期的对象。然后Java1.1的"反射"API却允许我们动态的使用类里的任何构造器。

## 



## 11.4 总结

利用RTTI可以根据一个匿名的基础类句柄调查处类型信息。但是只有在极特别的情况下才使用RTTI。但是为了多形性，要求我们拥有对基础类定义的控制权，因为有些时候在程序范围内，可能发现基础类并未包括我们想要的方法。若基础类来自一个库，或者由别的什么东西控制着，RTTI便是一个很好的解决方案：可继承一个新类型，然后添加自己的额外方法。在代码的其他地方，可以侦测自己的特定类型，并调用哪个特殊的方法。这样并不会破坏多形性以及程序的扩展能力，因为新类型的添加不要求查找程序中的switch语句。但是在需要新特性的主题种添加新代码时，必须使用RTTI侦测自己特定的类型。