<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

## 第二章 信息的表示和处理

1. 三种重要的数学表示方法
  * **无符号**：基于传统的二进制表示法，表示大于或者等于0的数字
  * **补码**：表示有符号整数最常见的方式。有符号整数就是可以为正或为负的数字
  * **浮点数**： 是表示实数的科学计数法表示的以二为基数的版本。

2. 计算机的表示法使用有限数量的位来对一个数字进行编码，因此当结果太大不能表示时，某些运算就会溢出。
3. 浮点运算时不可结合的。
4. 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示确实近似的。

### 2.1 信息存储
1. 位(bit), 字/字节(1Word = 8bit)。机器级程序将存储器视为一个非常大的字节数组，成为虚拟存储器。存储器的每个字节都由一个唯一的数字来标识，成为地址，所有可能的地址的集合成为虚拟地址空间。
2. C语言中一个指针的指（无论指向一个整数、一个结构或是某个对象）都是某个存储块的第一个字节的虚拟地址。**C编译器还把每个指针和类型信息联系在一起，这样就可以根据指针值得类型，生成不同的机器级代码来访问存储在指针所指向位置处的值**。

#### 2.1.1 十六进制表示法
1. 十六进制表示由OX开头，四个位表示一个一个十六位整数

#### 2.1.2 字
每台计算机都有一个字长。字长决定最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为w位的机器而言，虚拟地址的范围为<img src="http://chart.googleapis.com/chart?cht=tx&chl= [0, 2^w-1]" style="border:none;">

#### 2.1.3 数据大小
C语言中不同基本数据类型例如`char, short, int, float, double`等准确的字节数依赖于机器和编译器。对于指针来说，指针的大小即为机器的全字长，因此可以用来在虚拟空间寻址。
大多数情况，基本数据字节数如下表：

C声明 | 32位机器 | 64位机器
--- | --- | ---
char | 1 | 1
short int | 2 | 2
int | 4 | 4
long int | 4 | 8
long long int | 8 | 8
char * | 4 | 8
float | 4 | 4
double | 8 | 8

#### 2.1.4 寻址和字节顺序
对于有多个字节的对象，我们必须考虑建立规则：
* 这个对象的地址是什么？
* 在存储器中怎样存储这个对象、

几乎在所有的机器中，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

* **小端**：某些机器选择在存储中按照最低有效字节到最高有效字节的顺序存储对象，这种成为小端法。
* **大端**：与小端相反。

假设变量`x`的类型为`int`，位于地址Ox100处，它的十六进制表示为0x01234567。地址范围为0x100-0x103。

大端法：

0x100 | 0x101 | 0x102 | 0x100
 --- | --- | --- | ---
 01 | 23 | 45 | 67

 小端法：

0x100 | 0x101 | 0x102 | 0x100
--- | --- | --- | ---
67 | 45 | 23 | 01

注意，在0x01234567中，高位字节的十六进制为0x01，低位字节的值为0x67。

在实际使用中，可能会遇到大小端问题的场景有：
* 在不同类型的机器之间通过网络发送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反方向发送时就会发现，接受程序字里的字节成了反序的了。为了避免这种问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，确保发送方机器将它的内部表示转换成网络标准，而接收方机器将网络标准转换为它的内部标准。
* 第二种情况是当阅读表示证书数据的字节序列时字节顺序也很重要，比如读取反汇编代码时。
* 第三种情况是当编写规避正常的类型系统到程序时。例如在C语言中，强制类型转换(`cast`)允许一种数据类型引用一个对象，而这个数据类型与创建这个对象时定义的数据类型不同。

#### 2.1.5 表示字符串
C语言中字符串被编码为以一个null(其值为0x0)字符结尾的字符数组。

> **小技巧**：通过执行命令 `man ascii`可以得到一张ASCII字符码的表

> **小技巧**: 十进制数字X的ASCII正好是0x3X

#### 2.1.6 表示代码
不同的机器类型使用不相同的且不兼容的指令和编码方式。即使完全一样的进程运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能够不同机器和操作系统系统组合之间移植。

计算机系统的一个基本概念就是从机器的角度来看，程序仅仅是字节序列。机器没有出事源程序的任何信息，除了可能有的用来帮助调试的辅助表以外。

#### 2.1.7 布尔代数运算

#### 2.1.8 C语言中的位运算
确定一个位级运算最好的方法就是将十六进制的参数扩展成二进制表示并执行二进制运算。
>关于异或，一个还不错的技巧，X ^ 0 = X, X ^ 0XFF = ~X

#### 2.1.9 C语言中的逻辑运算
逻辑运算级 &&, ||, ! 这些运算符对应的运算。如果使用在数值上使用逻辑运算符，则最后的结果会退化为0x1或0x0。如：

表达式 | 结果
--- | ---
!0x41 | 0x00
!0x00 | 0x01
!!0x41 | 0x01
0x69 && 0x55 | 0x01
0x69\|\|0x55 | 0x01

#### 2.1.10 C语言中的移位运算
移位运算分为左移，逻辑右移，算数右移。其中左移之后，会补0，逻辑右移也会补0，但是算数右移会补最高有效位。一般来讲，**在各种语言中，右移运算都是算数右移**。

### 2.2 整数表示
#### 2.2.4 有符号数和无符号数之间的转换
1. 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。例如当将`short`型数值`-12345`强制类型转换为`unsigned short`型的时候，虽然他们表示的数值改变了，但是他们的机器码（位表示）是不变的。其他的也类似。
2. 对于相同位数值的有符号数和无符号数的数值，他们之间是有一定关系的。

#### 2.2.5 C语言中的有符号数与无符号数
1. 普通数值运算和逻辑运算时，如果类型不同都会发生隐式类型转换。
2. 通常，大多数数字都默认是有符号的，要创建一个无符号常亮，必须加上后缀字符`'U'`或`'u'`
3. 当执行一个运算时，如果它的一个运算数是有符号的，而另一个是无符号的，那么C语言将隐式的将有符号数强制类型转换为无符号数。

#### 2.2.6 扩展一个数字的位表示
1. 将一个无符号数转换到一个较大的类型，只需要简单的在表示的开头添加0，这种运算成为零扩展；将一个补码数字转换为一个更大的数据类型可以执行符号扩展，**规则是在表示中添加最高有效位值得副本**。

#### 2.2.7 截断数字
1. 与上一节 扩展一个数字的位表示相反，如果将一个位数较大的数字变成一个位数较小的数字时，需要截断多出来的高位。
